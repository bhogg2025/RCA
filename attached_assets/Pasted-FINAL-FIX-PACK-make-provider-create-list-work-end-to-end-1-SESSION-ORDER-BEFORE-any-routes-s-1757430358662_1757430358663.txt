FINAL FIX PACK — make provider create/list work end-to-end.

1) SESSION & ORDER (BEFORE any routes/static/catch-all)
app.set('trust proxy', 1);
app.use(cookieParser());
app.use(session({
  secret: process.env.JWT_SECRET,
  resave: false,
  saveUninitialized: false,
  name: 'sid',
  cookie: { httpOnly:true, sameSite:'lax', secure:true, maxAge:7*24*3600*1000, path:'/' }
}));

// mount ALL API routers AFTER session:
app.use('/api', apiRouter);

// only after that: app.use(express.static(...)); app.get('*', ...)

2) DEV-LOGIN that actually persists the cookie
app.post('/api/auth/dev-login', (req,res,next) => {
  if (process.env.EMAIL_DEV_MODE !== 'true') return res.status(404).json({code:'NOT_FOUND'});
  req.session.regenerate(err => {
    if (err) return next(err);
    req.session.user = { id:'dev', email:'dev@local', roles:['admin'] };
    req.session.save(err2 => err2 ? next(err2) : res.json({ ok:true }));
  });
});

3) WHOAMI (debug) and ADMIN GUARD
app.get('/api/admin/whoami', (req,res) => {
  const u = req.session?.user || null;
  res.json({ authenticated: !!u, roles: u?.roles || [] });
});
function adminOnly(req,res,next){
  const u = req.session?.user;
  if (!u) return res.status(401).json({code:'UNAUTHENTICATED', message:'Sign in'});
  if (!(u.roles||[]).includes('admin')) return res.status(403).json({code:'FORBIDDEN', message:'Admin only'});
  next();
}

// Dev-only bootstrap to avoid auth dead-ends:
const allowWhenBootstrapping = async (req,res,next) => {
  if (process.env.EMAIL_DEV_MODE === 'true') return next();
  next();
};

4) PROVIDERS ROUTES — return an ARRAY, never decrypt on GET
router.get('/admin/ai/providers', allowWhenBootstrapping, adminOnly, async (req,res) => {
  const result = await pool.query(`
    select id, provider, model_id as "modelId",
           is_active as "active", (key_ciphertext_b64 is not null) as "hasKey"
    from ai_providers where deleted_at is null order by created_at desc
  `);
  res.json(result.rows); // <— ARRAY
});

router.post('/admin/ai/providers', allowWhenBootstrapping, adminOnly, async (req,res) => {
  const { provider, modelId, apiKey, setActive } = req.body ?? {};
  if (!provider || !modelId || !apiKey)
    return res.status(400).json({code:'MISSING_FIELDS', message:'provider, modelId, apiKey are required'});
  const p = String(provider).trim().toLowerCase();
  const m = String(modelId).trim();
  const enc = encryptSecret(String(apiKey)); // AES-256-GCM with 12-byte IV

  const inserted = await pool.query(
    `insert into ai_providers (provider, model_id, key_ciphertext_b64, key_iv_b64, key_tag_b64, is_active, created_by)
     values ($1,$2,$3,$4,$5,$6,$7) returning id`,
    [p, m, enc.keyCiphertextB64, enc.keyIvB64, enc.keyTagB64, !!setActive, 'dev@local']
  );
  const id = inserted.rows[0].id;
  if (setActive) {
    await pool.query(`update ai_providers set is_active=false where id<>$1 and deleted_at is null`, [id]);
    await pool.query(`update ai_providers set is_active=true where id=$1`, [id]);
  }
  res.status(201).json({ id, provider:p, modelId:m, active:!!setActive, hasKey:true });
});

5) CRYPTO KEY — raw 32 chars, not base64
const K = process.env.CRYPTO_KEY_32 || process.env.AI_KEY_ENCRYPTION_SECRET;
if (!K || K.length !== 32) throw new Error('CRYPTO_KEY_32 must be exactly 32 chars');
const ENC_KEY = Buffer.from(K, 'utf8');

6) FRONTEND LIST HANDLING (defensive)
const res = await fetch('/api/admin/ai/providers', { credentials:'include' });
const data = await res.json().catch(()=>[]);
const list = Array.isArray(data) ? data : (Array.isArray(data.rows) ? data.rows : []);
setRows(list);

7) SELF-TEST (agent must paste results)
curl -i -X POST http://localhost:5000/api/auth/dev-login
curl -s     http://localhost:5000/api/admin/whoami
curl -i     http://localhost:5000/api/admin/ai/providers
# expect whoami.authenticated:true and providers=200 []
