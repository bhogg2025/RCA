1) Implement secret resolution + fail-fast boot
Create config/crypto-key.ts:
import fs from "fs";
export function loadCryptoKey(): string {
  const env = process.env.CRYPTO_KEY_32;
  if (env && env.length === 32) return env;

  const file = process.env.CRYPTO_KEY_FILE;
  if (file && fs.existsSync(file)) {
    const k = fs.readFileSync(file, "utf8").trim();
    if (k.length === 32) return k;
  }
  throw new Error(
    "Missing or invalid CRYPTO_KEY_32. Admin must set a 32-char key via env/secret."
  );
}
Wire it in security/crypto.ts:
import crypto from "crypto";
import { loadCryptoKey } from "../config/crypto-key";
const ALG = "aes-256-gcm";
const KEY = Buffer.from(loadCryptoKey(), "utf8");
export const encrypt = (s:string)=>{const iv=crypto.randomBytes(12);
  const c=crypto.createCipheriv(ALG,KEY,iv);
  const ct=Buffer.concat([c.update(s,"utf8"),c.final()]);
  const tag=c.getAuthTag();
  return Buffer.concat([iv,tag,ct]).toString("base64");};
export const decrypt = (b64:string)=>{const raw=Buffer.from(b64,"base64");
  const iv=raw.subarray(0,12),tag=raw.subarray(12,28),ct=raw.subarray(28);
  const d=crypto.createDecipheriv(ALG,KEY,iv); d.setAuthTag(tag);
  return Buffer.concat([d.update(ct),d.final()]).toString("utf8");};
Add a startup check (e.g., in server/index.ts):
import { loadCryptoKey } from "./config/crypto-key";
loadCryptoKey(); // throws if missing → process exits with clear message
2) Remove any UI/route that sets the master key
Delete any Admin-panel inputs for a “master/crypto key.”
Keep Status card only (reflecting config + compliance + last updated).
Keep Add AI Provider (with API Key) and AI Providers (Universal) table (no API key field).
Quick sweep:
rg -n -S "(master key|crypto key|CRYPTO_KEY_32|Set master key|bootstrap key)" client server
# remove any forms/endpoints that write a master key
3) Status surfaces (read-only)
/api/ai/config/status already drives the card; extend it to include "cryptoKey": "configured" | "missing" (no value).
UI: if "missing", show a non-blocking warning banner with a link to docs “Set CRYPTO_KEY_32 in your environment”.
4) Keep provider workflow exactly as designed
Add AI Provider: Provider dropdown fed from Universal table; Model ID; API Key input; “Set as active” checkbox; Test Key and Save Settings buttons.
Universal table: list provider+model; no API key column.
Backend still encrypts per-provider API keys using AES-256-GCM with the master key.
5) Admin instructions (for each environment)
Replit: Secrets panel → add CRYPTO_KEY_32 with a random 32-char string → Restart.
Docker Compose: create secrets/CRYPTO_KEY_32 (32 chars); set CRYPTO_KEY_FILE=/run/secrets/CRYPTO_KEY_32 and mount the secret.
Linux (systemd): set Environment=CRYPTO_KEY_32=<32 chars> in service unit → restart.
Windows: setx CRYPTO_KEY_32 "<32 chars>" → restart app.
macOS/desktop: env var or OS keychain (if you’ve added keytar support).
6) Guardrails against hardcoding
ESLint rule to block literal provider/model strings in code (except tests/docs).
CI grep to fail builds if common provider/model names appear outside allowed files.
Server logs must never print decrypted secrets; redact on error paths.
Add a health probe /health/crypto that returns { ok:true } only if loadCryptoKey() passes (no secrets in body).
7) Rotation (manual, not via panel)
Provide a small admin CLI/script to:
Set new CRYPTO_KEY_32 in environment/secret.
Re-encrypt stored provider keys (iterate, decrypt with old, encrypt with new).
Audit the rotation (who/when).
Final check (what “done” looks like)
App refuses to boot without a valid 32-char master key (clear error).
Admin panel does not contain any field to set/show the master key—only a status flag.
Adding/testing/saving provider API keys works end-to-end; keys are encrypted backend-side and never exposed to the client.
Universal table has no API key field; dropdowns are populated from it.